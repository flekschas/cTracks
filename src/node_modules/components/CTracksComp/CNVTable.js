import React from 'react';
import PropTypes from 'prop-types';

// New table
import ReactTable from 'react-table';
import checkboxHOC from './checkboxHOC';

import hamradio from 'hamradio'

import 'react-table/react-table.css';
import './CNVTable.css';

// include Higher Order Component (HOC) to React Table
const CheckboxTable = checkboxHOC(ReactTable);

function chromStringToEnum (chrom) {
  return !isNaN(chrom)
    ? parseInt(chrom,10)
    : chrom === 'X'
      ? 23
      : chrom === 'Y'
        ? 24 : 25
}

function computeHighlights(data, viewport) {
  if (!viewport) return []
  const chromRange = viewport.map(loc => chromStringToEnum(loc[0]))

  return data.map(row => {
      return {
        chrom: chromStringToEnum(row['#chrom']),
        start: row.start,
        stop: row.stop,
        id: row._id
      }
    })
    .filter(row => {
      if (row.chrom > chromRange[0] && row.chrom < chromRange[1]) return true // strictly between beginning and end chromosomes
      if (row.chrom === chromRange[0] && row.stop > viewport[0][1]) return true // at least some overlap on the lower boundary
      if (row.chrom === chromRange[1] && row.start < viewport[1][1]) return true // at least some overlap on the upper boundary
      return false
    })
    .map(row => row.id)
}

// generate data with ID information
function GenerateTableData(inputData)
{
  var Keys = Object.keys(inputData[0]);
  const data = inputData.map((item)=>{
    const _id = 'chr' + item[Keys[0]] + '-' + item[Keys[1]];
    return {
      _id,
      ...item,
    }
  })
  return data;
}

// generate automated column information for Table
function GenerateTableColumns(data)
{
  const columns = [];
  const sample = data[0];
  Object.keys(sample).forEach((key)=>{
    if(key!=='_id')
    {
      columns.push({
        accessor: key,
        Header: key,
      })
    }
  })
  return columns;
}

class CNVTable extends React.Component {
  constructor (props) {
    super(props);
    this.state = {
      TableData: [],
      TableColumns: [],
      HighlightIDs: [],
      selection: []
    };
    this.subscriptions = this.makeSubscriptions()
  }

  componentWillUnmount() {
    this.subscriptions.forEach(sub => sub.unsubscribe())
  }

  componentDidUpdate() {
  }

  makeSubscriptions () {
    return [
      hamradio.subscribe(
        'viewport/moved',
        (name, viewport) => {
          console.log('moved - cnv', viewport)
          this.setState(function () {
            return {
              viewport,
              HighlightIDs: computeHighlights(this.state.TableData, viewport)
            }
          })
        })
    ]
  }


  // Compare incoming Props with current props: new filtering and update when needed
  static getDerivedStateFromProps(nextProps, prevState) {
    let TableData = GenerateTableData(nextProps.CNVData)
    if (TableData.toString() !== prevState.TableData.toString()) {
      console.log('table changed')
      return {
        HighlightIDs: [],
        selection: [],
        TableData,
        TableColumns: GenerateTableColumns(TableData)
      }
    } else return null
  }

  shouldComponentUpdate(newProps, newState) {
    if (this.props.CNVData.toString() !== newProps.CNVData.toString()) return true
    if (this.state.HighlightIDs.toString() !== newState.HighlightIDs.toString()) return true
    if (this.state.selection.toString() !== newState.selection.toString()) return true
    return false
  }

  // toggleSelection in Table component
  toggleSelection = (key, shift, row) => {
    /*
      Implementation of how to manage the selection state is up to the developer.
      This implementation uses an array stored in the component state.
      Other implementations could use object keys, a Javascript Set, or Redux... etc.
    */
    // start off with the existing state
    let selection = [
      ...this.state.selection
    ];
    const keyIndex = selection.indexOf(key);
    // check to see if the key exists
    if (keyIndex >= 0) {
      // it does exist so we will remove it using destructing
      selection = [
        ...selection.slice(0, keyIndex),
        ...selection.slice(keyIndex + 1)
      ]
    } else {
      // it does not exist so add it
      selection.push(key);
    }
    // update the state
    this.setState({ selection });

    // update props CNVSelection
    this.props.onCNVSelection(selection);
  }

  // Internal function for table component
  isSelected = (key) => {
    /*
      Instead of passing our external selection state we provide an 'isSelected'
      callback and detect the selection state ourselves. This allows any implementation
      for selection (either an array, object keys, or even a Javascript Set object).
    */
    return this.state.selection.includes(key);
  }


  // function to handle row click
  handleRowClick (rowInfo) {
    const row = rowInfo.row
    hamradio.publish('highlight', [[[row['#chrom'], row.start], [row['#chrom'], row.stop]]])
  }

  // handle Table background info
  handleRowBackground (rowInfo) {
    var Color = null;
    const isFiltered = this.state.HighlightIDs.includes(rowInfo.original._id);
    //if (rowInfo.original._id === 'chr3-63821946') {
    if (isFiltered) {
      //Color = "rgb(182,190,254)";
      Color = 'PowderBlue';
    }
    return Color;
  }

	render () {
    console.log('render table')
    const { toggleSelection, isSelected } = this;
    const { TableData, TableColumns } = this.state;

    const checkboxProps = {
      isSelected,
      toggleSelection
    };

		return (
      <div>

        <div>
          {TableData && TableColumns &&
            <CheckboxTable
              ref={(r)=>this.checkboxTable=r}
              data={TableData}
              columns={TableColumns}
              defaultPageSize={this.state.TableData.length}
              style={{
                height: "400px"
              }}
              className="-striped -highlight"
              showPagination={false}
              {...checkboxProps}
              getTrProps={(state, rowInfo) => {
                const props = {
                  onClick: e => {
                    return this.handleRowClick(rowInfo);
                  },
                  style: {
                    background: this.handleRowBackground(rowInfo),
                  },
                };
                return props;
              }}
            />
          }
        </div>
      </div>
		)
	}
}

CNVTable.propTypes = {
  CNVData: PropTypes.array.isRequired,
  onCNVSelection: PropTypes.func.isRequired
}


export default CNVTable;
